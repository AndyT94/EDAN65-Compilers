package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short LPAR = 2;
		static public final short NUMERAL = 3;
		static public final short MUL = 4;
		static public final short DIV = 5;
		static public final short MOD = 6;
		static public final short PLUS = 7;
		static public final short MINUS = 8;
		static public final short EQUAL = 9;
		static public final short NOTEQUAL = 10;
		static public final short GREATER = 11;
		static public final short LESSER = 12;
		static public final short LESSEQUAL = 13;
		static public final short GREATEQUAL = 14;
		static public final short RPAR = 15;
		static public final short INT = 16;
		static public final short LBRACKET = 17;
		static public final short SEMICOLON = 18;
		static public final short BOOLEAN = 19;
		static public final short WHILE = 20;
		static public final short IF = 21;
		static public final short COMMA = 22;
		static public final short RBRACKET = 23;
		static public final short RETURN = 24;
		static public final short ASSIGN = 25;
		static public final short ELSE = 26;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"LPAR",
			"NUMERAL",
			"MUL",
			"DIV",
			"MOD",
			"PLUS",
			"MINUS",
			"EQUAL",
			"NOTEQUAL",
			"GREATER",
			"LESSER",
			"LESSEQUAL",
			"GREATEQUAL",
			"RPAR",
			"INT",
			"LBRACKET",
			"SEMICOLON",
			"BOOLEAN",
			"WHILE",
			"IF",
			"COMMA",
			"RBRACKET",
			"RETURN",
			"ASSIGN",
			"ELSE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9ojbKjp5KKOXjy#So0WId92Z8a4acEIav044Y0nYDo2W7X3K1IDe17D3x3SwCPouSg5vSg" +
		"LApTktBXnuyQDLOhW1LIytp2AWg88Yg2spynyETMJES65JDNJx$jztJCzVPaUoOrhi#vMbm" +
		"RLfaujKaL5ZMbS3#iABLIz6bHIe#v9MjshEIheCbhTvz$GN2tG3PbMhMfNlrPhHAEwJjThf" +
		"PPeo1$BvJVLRgcjkVnDkSoEN6QnobgkktBvV1$nA5Snogi3lruR6V4yHXYfZX5kqotu#RhJ" +
		"$9Wkn$S6xLi2lpJmVO7V4lZjWRyjyBkhlgFg1gfkkEgkhRerLRUswjObxXfSEeTnj4ATtgl" +
		"9CWzglthCf#MLQcQC5NKpndJsmjgqxCxN#6yokQioqOPCj2mJtMZHR7sbvJvMuMRTgjlHNR" +
		"fVEz4x$07jyMzgh$zB3x0M4$u2vKCygIrX2IjGPa#MvNZZBiRPIzzzhFi0Up9kiOYv6M8Nn" +
		"As6wRsRVH6sggEN#Upf1Qnpl9STxIBsyiny$VzecSyK#PBcrhWttyVqADipleFnb1XXL$BD" +
		"Dh6Y3Qn7YtcN#5MPzfVUNmgNpk5q9DOgpSGdIhtvj1najXfm5SQOpbvOcvQL6ZMDcLnh9gh" +
		"FHCsPg63HR7rDFw742XIWnAdIp9SNnuvU7RiwNY77c4f9AKq#gUGgm0dpyw057h7uKTF7Ox" +
		"qONCz8BaAFMpm0yIoEmLuuQVdJq0TduGBtkE0PvqsFfUgQe8ZPXzO1x#SMrkxVbQ0HU7$N2" +
		"ktG0HNeWUMm0bPQ7vD1ltF8ZwAhxLc3i1Qp4Hsst5POZzcEhe4XowyptKIno$m6qnsmq$hu" +
		"6Zy2cs4BxBOsss1FE1Rl$VV8XFapS0gxt#8fqtErvY4x9peG4yIFcOvFzsFn4wOlcBuUt7F" +
		"KT2B8FMNwekd1MVf$oVHbqrTCNpLzxIBlFWLFpyWzcwhh37BFMQuRbfhljxhdPtk#jIlFY8" +
		"S3FnhqCPcA$zlq3Fm6P$rfVyh$x7$o9$q9$wFLVclAYlkFp7y5H$qHVzY$YtidoVq1NyA7$" +
		"Zt$bZ$eFy1$0P$3P$0fVE8$zc$xS$vzVyYUD2MxabsIkb$yTvI$9luu$92utrMz$9z9UTx$" +
		"Wupoxt7yXs8A$8KYA712n1GvgHr4$AKS53ZLYtQgH9me1H3$BLUJ0UhxQRUCBwgFawgNUtj" +
		"Wa3pV52Tsz1yupkCem74MH#2gj2NdRaoKdD2B8JwxoyR8lzIBDaC=");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = function_list.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final List f = (List) _symbol_f.value;
					 return new Program(f);
				}
			},
			new Action() {	// [1] function_list = function.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Function a = (Function) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [2] function_list = function_list.a function.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Function b = (Function) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [3] params = LPAR id_list.a RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Params(a);
				}
			},
			new Action() {	// [4] params = LPAR RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Params();
				}
			},
			new Action() {	// [5] id_list = INT id_decl.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Id_decl a = (Id_decl) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [6] id_list = id_list.a COMMA INT id_decl.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final Id_decl b = (Id_decl) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [7] expr_list = expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [8] expr_list = expr_list.a COMMA expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [9] stmt_list = stmt.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Stmt a = (Stmt) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [10] stmt_list = stmt_list.a stmt.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [11] function = type.t id_decl.id params.l block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_id = _symbols[offset + 2];
					final Id_decl id = (Id_decl) _symbol_id.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final Params l = (Params) _symbol_l.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final Block b = (Block) _symbol_b.value;
					 return new Function(t, id, l, b);
				}
			},
			new Action() {	// [12] block = LBRACKET RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Block();
				}
			},
			new Action() {	// [13] block = LBRACKET stmt_list.a RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Block(a);
				}
			},
			new Action() {	// [14] else_block = ELSE block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return new Opt(b);
				}
			},
			new Action() {	// [15] else_block = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			Action.RETURN,	// [16] stmt = decl
			Action.RETURN,	// [17] stmt = assign
			Action.RETURN,	// [18] stmt = while
			Action.RETURN,	// [19] stmt = if
			Action.RETURN,	// [20] stmt = return
			Action.RETURN,	// [21] stmt = callStmt
			new Action() {	// [22] callStmt = functionExpr.f SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final FunctionExpr f = (FunctionExpr) _symbol_f.value;
					 return new CallStmt(f);
				}
			},
			new Action() {	// [23] return = RETURN expr.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new Return(e);
				}
			},
			new Action() {	// [24] while = WHILE LPAR expr.e RPAR block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new While(e,b);
				}
			},
			new Action() {	// [25] if = IF LPAR expr.e RPAR block.b else_block.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 6];
					final Opt c = (Opt) _symbol_c.value;
					return new If(e,b,c);
				}
			},
			new Action() {	// [26] assign = id_use.id ASSIGN expr.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final Id_use id = (Id_use) _symbol_id.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return new Assign(id,e);
				}
			},
			new Action() {	// [27] decl = type.t id_decl.id opt_assign.o SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_id = _symbols[offset + 2];
					final Id_decl id = (Id_decl) _symbol_id.value;
					final Symbol _symbol_o = _symbols[offset + 3];
					final Opt o = (Opt) _symbol_o.value;
					 return new Decl(t, id,o);
				}
			},
			new Action() {	// [28] opt_assign = ASSIGN expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new Opt(e);
				}
			},
			new Action() {	// [29] opt_assign = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			new Action() {	// [30] expr = expr.a PLUS term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					return new Add(a,b);
				}
			},
			new Action() {	// [31] expr = expr.a MINUS term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					return new Sub(a,b);
				}
			},
			new Action() {	// [32] expr = expr.a EQUAL term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Equal(a,b);
				}
			},
			new Action() {	// [33] expr = expr.a NOTEQUAL term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new NotEqual(a,b);
				}
			},
			new Action() {	// [34] expr = expr.a GREATER term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Greater(a,b);
				}
			},
			new Action() {	// [35] expr = expr.a LESSER term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Lesser(a,b);
				}
			},
			new Action() {	// [36] expr = expr.a LESSEQUAL term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LessEqual(a,b);
				}
			},
			new Action() {	// [37] expr = expr.a GREATEQUAL term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GreatEqual(a,b);
				}
			},
			Action.RETURN,	// [38] expr = term
			new Action() {	// [39] term = term.a MUL factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a,b);
				}
			},
			new Action() {	// [40] term = term.a DIV factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a,b);
				}
			},
			new Action() {	// [41] term = term.a MOD factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a,b);
				}
			},
			Action.RETURN,	// [42] term = factor
			RETURN2,	// [43] factor = LPAR expr.e RPAR
			Action.RETURN,	// [44] factor = numeral
			Action.RETURN,	// [45] factor = id_use
			Action.RETURN,	// [46] factor = functionExpr
			new Action() {	// [47] functionExpr = id_use.f exprs.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final Id_use f = (Id_use) _symbol_f.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final Exprs l = (Exprs) _symbol_l.value;
					 return new FunctionExpr(f, l);
				}
			},
			new Action() {	// [48] exprs = LPAR RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Exprs();
				}
			},
			new Action() {	// [49] exprs = LPAR expr_list.a RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Exprs(a);
				}
			},
			new Action() {	// [50] id_decl = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return new Id_decl(id);
				}
			},
			new Action() {	// [51] id_use = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return new Id_use(id);
				}
			},
			new Action() {	// [52] numeral = NUMERAL.num
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol num = _symbols[offset + 1];
					 return new Numeral(num);
				}
			},
			new Action() {	// [53] type = INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new IntType();
				}
			},
			new Action() {	// [54] type = BOOLEAN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new BoolType();
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
