package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short LPAR = 2;
		static public final short NUMERAL = 3;
		static public final short MUL = 4;
		static public final short DIV = 5;
		static public final short MOD = 6;
		static public final short PLUS = 7;
		static public final short MINUS = 8;
		static public final short EQUAL = 9;
		static public final short NOTEQUAL = 10;
		static public final short GREATER = 11;
		static public final short LESSER = 12;
		static public final short LESSEQUAL = 13;
		static public final short GREATEQUAL = 14;
		static public final short RPAR = 15;
		static public final short INT = 16;
		static public final short LBRACKET = 17;
		static public final short SEMICOLON = 18;
		static public final short WHILE = 19;
		static public final short IF = 20;
		static public final short COMMA = 21;
		static public final short RBRACKET = 22;
		static public final short RETURN = 23;
		static public final short ASSIGN = 24;
		static public final short ELSE = 25;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"LPAR",
			"NUMERAL",
			"MUL",
			"DIV",
			"MOD",
			"PLUS",
			"MINUS",
			"EQUAL",
			"NOTEQUAL",
			"GREATER",
			"LESSER",
			"LESSEQUAL",
			"GREATEQUAL",
			"RPAR",
			"INT",
			"LBRACKET",
			"SEMICOLON",
			"WHILE",
			"IF",
			"COMMA",
			"RBRACKET",
			"RETURN",
			"ASSIGN",
			"ELSE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9ojLJbq54SG$RDQn8rM4a822KcBLlSAiO2umTo7CPZxlic8UF08U8$t824Y8Y8X8N7YX8I" +
		"4X8o0qzo7CI2mCTZc4EQ#YjyzfQ5dPvS4Tj#l#bLTNTNLqzC3U8im7IkGGZj6eWwJyGEsO1" +
		"NYw8y1A482nIYn4J4Ko3tqGPESmZJqHNaeOZ1gq8fHwC1OZCT4P30K8#H#n3yrToHcHVpp8" +
		"fw54KybacZ3yeW$MiFqLyN#Cawd5Lgx51kn2RCndwmtbbhM0$t8liHMExp5uJCTFjVX2no#" +
		"BE130bORi7J0HWTiJC361Mn2m2PPDinsOzPlhE61vSj2DEhkk5vVhiunqZFawnMofeMiWI6" +
		"hGQryjVnp89Y2Cip0MiOFGZFg#L#7EQpp8twYZEDdBC9YB25VWvNoWJNNOuEyfzxCNQkqg6" +
		"AkQZvPqtc26HhOOnEpjTZHDlfBMD7iaSU8Yb14JsRkpTFRby$Ld5lFd6V6P$kBlY4owedp7" +
		"1Ncc1kjqTsV5#hKhvsmRrafTpx1tIkthDOoD$RxyE$B$FM7BL#siYT$TrolBsCvHf8XNt5M" +
		"X6lLXgpkNFbg#H9SJOOdfeXM2KzgYlyoycBMDJ91dUQjaYGVpeXYpakmaj6rdBrr7uM8l0E" +
		"yZE7yLH2lY3TgRrUzo#YlWJcAABWghrxdD1ELn1HYDR57$VU9Hk81yP1uukGOhJ6trAwZw2" +
		"BM42#8byJxtFNnoRJ3EJs8Gg8VqPye9GOIGmYknwlM#2rEtIeYHJ92xGc4MUCawhJw9XCj9" +
		"BEesubMzNUeRgDOg7oCiwuTj1k8SSH4Ofx6cDmBt1xuB1uGptNUDk84qTazflfrhlwpzk8r" +
		"SySSUxtgGwfNgTwf#h3g4ywUb6czXqwUtQgFg3wPf$ulgdzLVLJrCTN7yw$T6qInDolVVXq" +
		"RwlWEg2z9b2jFwTZ1FBa7PzbfXxSxkRVwIZwgvjcJ$ucNyboUoXDvBF$9l$AFZlwfkfEuhl" +
		"mkSKqkoKNvZUoyzV6fo1tYgboGqt96hf3V9luWRX6$4pVbXfoJDt9Ppcgclw0$#JjWpuHlZ" +
		"tHPpdT87iah13zvQ#KxCMz4X$soj5d4U8EPMop6#y0Wpk#EHnJm2#GHCNwDulRsIDANfaup" +
		"GvtzCaNHml5cnZNobchYFTN0kVL4XluCvzLmxElmUEiMEF1uunOGNe1AvafPc3lIV6SyUoU" +
		"F#Wo8H2rJ");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = function_list.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final List f = (List) _symbol_f.value;
					 return new Program(f);
				}
			},
			new Action() {	// [1] function_list = function.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Function a = (Function) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [2] function_list = function_list.a function.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Function b = (Function) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [3] params = LPAR id_list.a RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Params(a);
				}
			},
			new Action() {	// [4] params = LPAR RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Params();
				}
			},
			new Action() {	// [5] id_list = INT id_decl.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Id_decl a = (Id_decl) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [6] id_list = id_list.a COMMA INT id_decl.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final Id_decl b = (Id_decl) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [7] expr_list = expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [8] expr_list = expr_list.a COMMA expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [9] stmt_list = stmt.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Stmt a = (Stmt) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [10] stmt_list = stmt_list.a stmt.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [11] function = INT id_decl.id params.l block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final Id_decl id = (Id_decl) _symbol_id.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final Params l = (Params) _symbol_l.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final Block b = (Block) _symbol_b.value;
					 return new Function(id, l, b);
				}
			},
			new Action() {	// [12] block = LBRACKET RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Block();
				}
			},
			new Action() {	// [13] block = LBRACKET stmt_list.a RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Block(a);
				}
			},
			new Action() {	// [14] else_block = ELSE block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return new Opt(b);
				}
			},
			new Action() {	// [15] else_block = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			Action.RETURN,	// [16] stmt = decl
			Action.RETURN,	// [17] stmt = assign
			Action.RETURN,	// [18] stmt = while
			Action.RETURN,	// [19] stmt = if
			Action.RETURN,	// [20] stmt = return
			Action.RETURN,	// [21] stmt = callStmt
			new Action() {	// [22] callStmt = functionExpr.f SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final FunctionExpr f = (FunctionExpr) _symbol_f.value;
					 return new CallStmt(f);
				}
			},
			new Action() {	// [23] return = RETURN expr.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new Return(e);
				}
			},
			new Action() {	// [24] while = WHILE LPAR expr.e RPAR block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new While(e,b);
				}
			},
			new Action() {	// [25] if = IF LPAR expr.e RPAR block.b else_block.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 6];
					final Opt c = (Opt) _symbol_c.value;
					return new If(e,b,c);
				}
			},
			new Action() {	// [26] assign = id_use.id ASSIGN expr.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final Id_use id = (Id_use) _symbol_id.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return new Assign(id,e);
				}
			},
			new Action() {	// [27] decl = INT id_decl.id opt_assign.o SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final Id_decl id = (Id_decl) _symbol_id.value;
					final Symbol _symbol_o = _symbols[offset + 3];
					final Opt o = (Opt) _symbol_o.value;
					 return new Decl(id,o);
				}
			},
			new Action() {	// [28] opt_assign = ASSIGN expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new Opt(e);
				}
			},
			new Action() {	// [29] opt_assign = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			new Action() {	// [30] expr = expr.a PLUS term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					return new Add(a,b);
				}
			},
			new Action() {	// [31] expr = expr.a MINUS term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					return new Sub(a,b);
				}
			},
			new Action() {	// [32] expr = expr.a EQUAL term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Equal(a,b);
				}
			},
			new Action() {	// [33] expr = expr.a NOTEQUAL term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new NotEqual(a,b);
				}
			},
			new Action() {	// [34] expr = expr.a GREATER term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Greater(a,b);
				}
			},
			new Action() {	// [35] expr = expr.a LESSER term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Lesser(a,b);
				}
			},
			new Action() {	// [36] expr = expr.a LESSEQUAL term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LessEqual(a,b);
				}
			},
			new Action() {	// [37] expr = expr.a GREATEQUAL term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GreatEqual(a,b);
				}
			},
			Action.RETURN,	// [38] expr = term
			new Action() {	// [39] term = term.a MUL factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a,b);
				}
			},
			new Action() {	// [40] term = term.a DIV factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a,b);
				}
			},
			new Action() {	// [41] term = term.a MOD factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a,b);
				}
			},
			Action.RETURN,	// [42] term = factor
			RETURN2,	// [43] factor = LPAR expr.e RPAR
			Action.RETURN,	// [44] factor = numeral
			Action.RETURN,	// [45] factor = id_use
			Action.RETURN,	// [46] factor = functionExpr
			new Action() {	// [47] functionExpr = id_use.f exprs.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final Id_use f = (Id_use) _symbol_f.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final Exprs l = (Exprs) _symbol_l.value;
					 return new FunctionExpr(f, l);
				}
			},
			new Action() {	// [48] exprs = LPAR RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Exprs();
				}
			},
			new Action() {	// [49] exprs = LPAR expr_list.a RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Exprs(a);
				}
			},
			new Action() {	// [50] id_decl = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return new Id_decl(id);
				}
			},
			new Action() {	// [51] id_use = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return new Id_use(id);
				}
			},
			new Action() {	// [52] numeral = NUMERAL.num
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol num = _symbols[offset + 1];
					 return new Numeral(num);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
